import time
import matplotlib.pyplot as plt
import numpy as np
import timeit
"""
Initially I started with a recursive approach as it seemed like the simplest solution, 
but I used too much memory with that approach. Since the only necessary values are the two previous,
it makes more sense to go with an iterative solution where only the two previous values are saved.

Space: O(1)
Time: O(n)
Please see the runtime.png file located in the src directory for a visualization, or feel free to run the code below.

The output of sequence(10000) is:
645145067444270761356716481857445357641649553114979126977678963754439951082038984632678061418130657858763297544529821984444895464626862603691739802477466631503873767432694953865148667058442664481918025121653166100343954869841332731542457362834113318740074258352418751185500785071084474652030341872751114517691124799298946476356463130421256001538326419686685024658804199090849748412873447604535750572396245530424783088241899918727047006913682721495224443247600409827124799470185578822892780248099201063388167346497317474442071198019623551456189630759811865831617485719078716492727748680645636681156261142523348830419155615693078563602052074308536791767398023563062654117446029432097791614030894600205918745588000027749241499556416620236383481141542139618267239995908984466111486647077115808307902368887069463321555768022390997259037097147923161550796376448633639191058160377727679526847368225829716455421516498274839007505526603632830905156575689466421113905804893041617407988995957582361699110853657191118269861280913215596304247181727470222880786012786174601277208667732522083157085633502053869442681988756433014137552047292645249667623080960158029307041797974528005411231083666859195730472054478916752735859020924743323704976823318050126745409118196223466719223339522073412802366352813857415809629646773071321021322915809378632028416028413299468319362402530515502588589399067652778615784607050131186014530406266363654361196873709332572288106710280508411833502919921220462451339963101921144001361401160661249966470252485720782595383560914505654141717325381005598727773686382562943798678618507388289518297731421477986248887295505359290084507833070865662747168546322649930506385522948488952975319520205239729675192003571242819758609748037543641240137577371696785255726670121334640733501179715052678269583483097831741247328687771258281063372501649165518987809812008399308777781407031699396066250798983206988348120665
"""
def sequence(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    minusOne = 2
    minusTwo = 1
    result = 0
    for i in range(3, n + 1):
        if i % 2 == 0:
            result = minusOne + minusTwo
        else: 
            result = 2 * minusOne - minusTwo
        minusTwo = minusOne
        minusOne = result
    return result

print(f"The layup sequence for 10000 is {sequence(10000)}")


n_values = np.linspace(100, 10000, num=1000, dtype=int) 
runtimes = []

for n in n_values:
    runtime = timeit.timeit(lambda: sequence(n), number=10) / 10  # Averaging over 10 runs
    runtimes.append(runtime)

# Reference O(n) line
linear_runtime = (max(runtimes) / max(n_values)) * n_values


# Plot runtime
plt.figure(figsize=(10, 5))
plt.plot(n_values, runtimes, marker='o', linestyle='-', label="Measured Runtime")
plt.plot(n_values, linear_runtime, linestyle="--", color="red", label="O(n) Reference Line")
plt.xlabel("n")
plt.ylabel("Runtime (seconds)")
plt.title("Runtime of Layup Sequence Function")
plt.legend()
plt.grid(True)
plt.show()

